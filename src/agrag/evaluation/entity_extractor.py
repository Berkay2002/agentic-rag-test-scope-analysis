"""Entity ID extraction from agent responses.

This module provides utilities to extract entity IDs (TC_*, REQ_*, FUNC_*, etc.)
from natural language responses generated by the agent.
"""

import re
import logging
from typing import List, Set, Dict, Any
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


# Entity ID patterns for different entity types
ENTITY_PATTERNS = {
    "TestCase": r"TC_[A-Z]+_\d+",
    "Requirement": r"REQ_[A-Z]+_\d+",
    "Function": r"FUNC_[A-Za-z_]+(?:_\d+)?",
    "Class": r"CLASS_[A-Za-z_]+(?:_\d+)?",
    "Module": r"MOD_[A-Za-z_.]+(?:_\d+)?",
}

# Compiled patterns for efficiency
COMPILED_PATTERNS = {
    entity_type: re.compile(pattern) for entity_type, pattern in ENTITY_PATTERNS.items()
}


@dataclass
class ExtractionResult:
    """Result of entity ID extraction from text."""

    # All extracted IDs (preserving order)
    all_ids: List[str] = field(default_factory=list)

    # IDs grouped by entity type
    by_type: Dict[str, List[str]] = field(default_factory=dict)

    # Count of each entity type
    counts: Dict[str, int] = field(default_factory=dict)

    @property
    def test_case_ids(self) -> List[str]:
        """Get test case IDs."""
        return self.by_type.get("TestCase", [])

    @property
    def requirement_ids(self) -> List[str]:
        """Get requirement IDs."""
        return self.by_type.get("Requirement", [])

    @property
    def function_ids(self) -> List[str]:
        """Get function IDs."""
        return self.by_type.get("Function", [])

    @property
    def total_count(self) -> int:
        """Get total number of extracted IDs."""
        return len(self.all_ids)


def extract_entity_ids(
    text: str,
    prioritize_test_cases: bool = True,
) -> List[str]:
    """
    Extract entity IDs from text.

    Patterns matched:
    - TC_SIGNALING_126, TC_HANDOVER_200 (test cases)
    - REQ_AUTH_005, REQ_HANDOVER_001 (requirements)
    - FUNC_initiate_handover (functions)
    - CLASS_HandoverManager (classes)
    - MOD_authentication (modules)

    Args:
        text: The text to extract IDs from (typically agent response)
        prioritize_test_cases: If True, return test cases first

    Returns:
        List of unique entity IDs, preserving order of first occurrence
    """
    if not text:
        return []

    test_case_ids: List[str] = []
    other_ids: List[str] = []
    seen: Set[str] = set()

    # Extract IDs by type
    for entity_type, pattern in COMPILED_PATTERNS.items():
        matches = pattern.findall(text)
        for match in matches:
            if match not in seen:
                seen.add(match)
                if entity_type == "TestCase":
                    test_case_ids.append(match)
                else:
                    other_ids.append(match)

    # Return with test cases first if prioritized
    if prioritize_test_cases:
        return test_case_ids + other_ids
    else:
        # Preserve original order from text
        all_ids: List[str] = []
        seen_final: Set[str] = set()

        # Find all matches with their positions
        all_matches: List[tuple] = []
        for entity_type, pattern in COMPILED_PATTERNS.items():
            for match in pattern.finditer(text):
                all_matches.append((match.start(), match.group()))

        # Sort by position and deduplicate
        all_matches.sort(key=lambda x: x[0])
        for _, entity_id in all_matches:
            if entity_id not in seen_final:
                seen_final.add(entity_id)
                all_ids.append(entity_id)

        return all_ids


def extract_entity_ids_detailed(text: str) -> ExtractionResult:
    """
    Extract entity IDs with detailed type information.

    Args:
        text: The text to extract IDs from

    Returns:
        ExtractionResult with IDs grouped by type
    """
    if not text:
        return ExtractionResult()

    result = ExtractionResult()
    seen: Set[str] = set()

    # Initialize by_type dict
    for entity_type in ENTITY_PATTERNS.keys():
        result.by_type[entity_type] = []
        result.counts[entity_type] = 0

    # Extract IDs by type
    for entity_type, pattern in COMPILED_PATTERNS.items():
        matches = pattern.findall(text)
        for match in matches:
            if match not in seen:
                seen.add(match)
                result.all_ids.append(match)
                result.by_type[entity_type].append(match)
                result.counts[entity_type] += 1

    logger.debug(f"Extracted {result.total_count} entity IDs: " f"{result.counts}")

    return result


def extract_from_tool_results(messages: List[Any]) -> List[str]:
    """
    Extract entity IDs from tool result messages.

    This is useful for analyzing what entities the tools returned
    during the agent execution.

    Args:
        messages: List of messages from agent execution

    Returns:
        List of unique entity IDs found in tool results
    """
    from langchain_core.messages import ToolMessage

    all_ids: List[str] = []
    seen: Set[str] = set()

    for msg in messages:
        if isinstance(msg, ToolMessage):
            content = str(msg.content)
            ids = extract_entity_ids(content, prioritize_test_cases=True)
            for entity_id in ids:
                if entity_id not in seen:
                    seen.add(entity_id)
                    all_ids.append(entity_id)

    return all_ids


def normalize_entity_id(entity_id: str) -> str:
    """
    Normalize an entity ID (e.g., handle case variations).

    Args:
        entity_id: Raw entity ID

    Returns:
        Normalized entity ID
    """
    # Most IDs use uppercase for prefix, preserve as-is for functions
    if entity_id.startswith(("FUNC_", "CLASS_", "MOD_")):
        return entity_id

    # For TC_ and REQ_, ensure uppercase
    parts = entity_id.split("_", 1)
    if len(parts) == 2 and parts[0] in ("TC", "REQ"):
        return entity_id.upper()

    return entity_id
